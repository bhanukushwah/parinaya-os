---
phase: 01-multi-event-foundation-governance-controls
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - packages/api/src/policies/authorize.ts
  - packages/api/src/services/audit-log.ts
  - packages/api/src/routers/events.ts
autonomous: true
user_setup: []
must_haves:
  truths:
    - "Parent Admin can create, edit, archive, restore, and reorder events with persistence-focused commands."
    - "Invite-only events are excluded from public event listings."
    - "Invite-only event reads enforce login first and then eligibility checks with immediate revocation after visibility changes."
    - "Blocked governance actions return a generic authorization error without role-disclosure details."
  artifacts:
    - path: packages/api/src/policies/authorize.ts
      provides: Central role/action policy matrix and generic forbidden guard
      min_lines: 40
      contains: ORPCError
    - path: packages/api/src/services/audit-log.ts
      provides: Append-only audit write helper for event and governance actions
      min_lines: 40
      contains: export async function writeAuditLog
    - path: packages/api/src/routers/events.ts
      provides: Event lifecycle and visibility read/write procedures
      min_lines: 120
      contains: export const eventsRouter
  key_links:
    - from: packages/api/src/routers/events.ts
      to: packages/api/src/policies/authorize.ts
      via: role gate calls before mutations
      pattern: assertCan\(
    - from: packages/api/src/routers/events.ts
      to: packages/api/src/services/audit-log.ts
      via: transactional mutation plus audit append
      pattern: writeAuditLog\(
    - from: packages/api/src/routers/events.ts
      to: packages/db/src/schema/events.ts
      via: drizzle event queries and visibility filters
---

<objective>
Implement API domain logic for event lifecycle and visibility enforcement.

Purpose: Deliver enforceable backend behavior for EVT-01 and EVT-02 while honoring locked governance and UX constraints.
Output: Central authorization utilities, audit log writer, and an events router with lifecycle/visibility procedures.
</objective>

<execution_context>
@~/.kilocode/skills/execute-plan/SKILL.md
@.gsd/templates/summary.md
</execution_context>

<context>
@.gsd/ROADMAP.md
@.gsd/REQUIREMENTS.md
@.gsd/phases/01-multi-event-foundation-governance-controls/01-CONTEXT.md
@.gsd/phases/01-multi-event-foundation-governance-controls/01-RESEARCH.md
@.gsd/phases/01-multi-event-foundation-governance-controls/01-01-SUMMARY.md
@packages/api/src/index.ts
@packages/api/src/context.ts
@packages/db/src/index.ts
</context>

<tasks>
<task type="auto">
  <name>Task 1: Implement reusable authorization policy with generic blocked errors</name>
  <files>packages/api/src/policies/authorize.ts</files>
  <action>Create a centralized policy matrix for owner/admin/coordinator permissions covering event lifecycle actions and governance controls. Expose helpers such as `assertCan`, `assertRoleChangeAllowed`, and role lookup by workspace membership. Ensure all blocked outcomes throw a single generic forbidden message and do not leak required-role details.</action>
  <verify>`bun run check-types` passes with the new policy module imported by router code.</verify>
  <done>Policy helpers can be called by any router to enforce role boundaries consistently with locked decisions.</done>
</task>

<task type="auto">
  <name>Task 2: Build transactional audit log service for critical writes</name>
  <files>packages/api/src/services/audit-log.ts</files>
  <action>Implement append-only audit writer utilities that accept actor, action type, target, before/after summary, optional reason, and transaction client. Include typed action names for required Phase 1 coverage (`role.change`, `event.visibility.change`) and future operational entries (`invite.send`, `guest.edit`) so later phases can reuse the same service without API churn.</action>
  <verify>Type signatures compile and action constants are consumable from router modules.</verify>
  <done>Audit writes are standardized and can be invoked inside DB transactions for atomic change+audit behavior.</done>
</task>

<task type="auto">
  <name>Task 3: Implement events router with lifecycle commands and visibility guards</name>
  <files>packages/api/src/routers/events.ts</files>
  <action>Create `eventsRouter` procedures for create/edit/archive/restore/reorder/list-public/get-detail. Enforce defaults (`draft`, `invite-only`) on creation, last-write-wins updates, global reorder persistence, and soft-restore behavior. For invite-only details, run login-first check followed by eligibility verification against persisted grants; deny with generic auth error when unauthorized. Ensure public list excludes invite-only rows. Wrap critical mutations in DB transactions and append audit entries via audit service.</action>
  <verify>`bun run check-types` succeeds and router exports are available for composition.</verify>
  <done>Event lifecycle and visibility controls are fully encoded at server boundary with audit emission for critical changes.</done>
</task>
</tasks>

<verification>
- [ ] `bun run check-types` succeeds after adding event router/policy/service modules.
- [ ] Public listing procedure filters out `invite-only` events by query predicate.
- [ ] Invite-only detail procedure enforces auth-first then eligibility checks and returns generic forbidden on failure.
- [ ] Create/edit/archive/restore/reorder procedures each append audit records in the same transaction as data mutation.
</verification>

<success_criteria>
- All tasks completed.
- Event lifecycle API behavior matches locked context decisions.
- Visibility enforcement is read-time safe and leak resistant.
- Authorization and audit logic are centralized and reusable for remaining phase work.
</success_criteria>

<output>
After completion, create `.gsd/phases/01-multi-event-foundation-governance-controls/01-02-SUMMARY.md`.
</output>
